시험시간 2시간(범위 : 변수 ~ 상속)
개념 서술형 2문제(소문제있음-부분점수)
코드작성 3문제(로직없으면 -10점)
	로직작성 1문제 methodTest.MethodTask
	코드작성 2문제(1문제는 반복문 구구단), day09~day11 내용 중 1개

10일차 코드 확인 /깊은복사,얕은복사, 정렬x
11일차?

 프로그램의 동작원리
	<일반 프로그램>	<JAVA>
	프로그램		프로그램
				JVM
	운영체제(OS)	운영체제(OS)
	하드웨어		하드웨어

	일반프로그램이 실행 -> 프로그램을 구성하는 명령어와 데이터가 운영체제에 의해 메모리(RAM)에 적재
	-> 프로그램이 메모리에 적재되어 실행 중인 상태(프로세스) -> CPU가 메모리에 있는 exe 파일 해석 및 실행

- JVM(Java Virtual Machine)
	운영체제에 맞춰서 java로 만든 프로그램을 실행시켜준다
	
	javac : .java파일(사람의 언어로 된 파일) 컴파일
	java : .class파일(컴퓨터 언어로 된 파일) 실행
	
	작성한 소스코드는 .java 파일로 만들어짐 -> 자바 컴파일러가 .class 파일로 변환(java bytecode)
	-> JVM이 OS(운영체제)가 bytecode를 이해할 수 있도록 도와줌
	자바 컴파일러는 jdk를 설치하면 bin폴더에 존재하는 javac.exe 파일을 의미한다

- JRE(Java Runtime Environment)
	JVM을 실행한다
	JVM을 실행할 때 필요한 라이브러리 파일 등을 가지고 있다

- JDK(Java Depelopment Kit)
	JRE을 포함한다
	JRE 외에 개발에 필요한 도구들을 가지고 있다


메모리 5가지 영역 중 3가지 영역
+) 메모리 구조
Method 영역 *
	- 모든 클래스와 static 멤버가 저장되는 영역
	- 클래스 로더가 클래스를 로드할 때 해당 클래스의 메타 데이터와 함께
	  static 변수와 static 메소드가 여기에 저장된다
	- 프로그램 실행 동안 유지되며 모든 객체가 공유한다

Heap 영역 *
	- new 키워드로 생성된 객체와 그 객체의 인스턴스 변수(필드)가 저장된다
	- 객체마다 별도의 저장공간을 가진다
	- Garbage Collector(가비지 컬렉터)가 관리한다

Stack 영역 *
	- 메소드의 지역변수, 매개변수와 메소드 실행정보가 저장되는 영역
	- 메소드가 호출될 때 스택 프레임이 생성되고 종료되면 프레임이 제거된다

PC Register(프로그램 카운터 레지스터)
	- 각 쓰레드가 실행 중인 명령어의 주소를 저장

Native Method Stack(네이티브 메소드 스택)
	- Java가 아닌 네이티브 코드(C, C++ 등)로 작성된 메소드를 호출 시 사용

stack 영역		매개변수, 지역변수, 메소드 실행정보가 저장되는 영역
heap 영역		new 키워드로 생성된 객체와 그 객체의 인스턴스 변수가 저장되는 영역
			(객체마다 별도의 공간을 가짐)
method 영역	모든 클래스와 static 멤버가 저장되는 영역
			프로그램 실행동안 유지되며 모든 객체가 공유한다

+) Runtime Data Area : JVM이 프로그램을 실행하는 동안 사용하는 메모리 영역
	JVM의 메모리 영역은 OS(운영체제)에게 할당받은 메모리이다
	운영체제로부터 할당받은 메모리 공간 내에서 독자적으로 메모리를 관리하고 이를 여러 영역으로 나누어 사용한다
	따라서 JVM의 메모리 영역은 운영체제의 메모리 영역과는 분리되어 동작된다
	크게 5개의 영역으로 구분되며 힙영역, 스택영역, 메소드영역, 프로그램 카운터 레지스터, 네이티브 메소드 스택

- 힙영역(Heap Area)
	객체와 배열이 생성되는 메모리 공간
	new 연산자로 생성되는 객체나 배열이 할당
	동적 메모리 할당을 사용하기 떄문에 프로그램이 실행 중에 메모리의 크기를 동적으로 조정할 수 있다
	
- 스택영역(Stack Area)
	메소드 호출(사용) 시에 사용하는 메모리 공간
	메소드가 호출될 때마다 스택에 새로운 프레임이 생성되며 메소드 종료 시에는 해당 프레임이 제거된다
	각 쓰레드마다 별도의 스택 영역을 가지며 동시에 여러 메소드가 호출될 수 있다

- 메소드영역(Method Area)
	클래스의 정보, static 변수, 상수 등이 저장되는 메모리 공간
	메소드 영역 JVM이 실행될 때 생성되며, 모든 쓰레드가 공유한다

- 프로그램 카운터 레지스터(PC Register)
	프로그램 카운터 레지스터는 현재 실행 중인 명령어의 주소를 저장하는 메모리 공간
	JVM이 쓰레드를 생성할 때마다 쓰레드마다 별도의 PC Register를 가진다

- 네이티브 메소드 스택(Native Method Stack)
	JNI(Java Native Interface)를 사용하여 호출되는 C/C++ 메소드의 스택영역이다



Java 특징
	객체지향언어 - 클래스,객체,상속, (별표)다형성(별표)

형변환 	- 강제형변환/자동형변환 - 기본자료형끼리의 형변환  
		- 문자열과 다른자료형의 형변환

비트연산자 시험안나옴

제어문
반복문

7일차 실습 문제 전체 복습 - 코인노래방 뺴고

1) 배열
	하나의 타입으로 여러개의 값을 저장할 수 있는 저장공간

2) 배열의 사용목적
	데이터의 집합을 효율적으로 관리하기 위한 목적
	데이터의 순서를 보존하기 위한 목적
	반복문을 사용하여 배열의 요소를 처리하기 위한 목적
	메모리를 효율적으로 사용하기 위한 목적
	데이터를 정렬하거나 검색하기 위한 목적
	
3) 배열의 선언
- 배열변수의 선언 
	자료형[] 참조변수;
	자료형 참조변수[];

- 배열의 생성과 초기화
	자료형[] 참조변수 = new 자료형[];
	자료형[] 참조변수 = new 자료형[]{값1, 값2, 값3, ...};
	자료형[] 참조변수 = {값1, 값2, 값3, ...};

4) 배열의 구조
	int[]	ar	=	new	int[3];
	-----------		---------------
	Stack 영역		Heap 영역


8일차
이중포문 실습 구구단 1-4번 문제

배열복습X

정렬X

메소드 호출 방법


10일차
	메소드 - 꼭꼭꼭 복습

callbyvalue callbyreference 안나옴

객체지향언어 특징 4개 - 클래스,객체,상속, (별표)다형성(별표)

3. 객체지향언어(OOP, Object-Oriented Programming)
	프로그램을 객체로 구성하고 이 객체들 간의 상호작용을 통해 문제를 해결하는 방식

1) 캡슐화(Encapsulation)
	객체의 데이터를 보호하고 외부에서 접근할 수 있는 방법을 제한하는 개념
	객체 => 데이터를 포함한 속성과 동작을 정의하는 메소드를 하나로 묶은 것을 의미
	객체 외부에서 내부 데이터를 직접 변경하지 못하게 하고 허용된 메소드를 통해서만 데이터를 변경하거나 사용할 수 있게 한다
	데이터(필드)를 private 접근제한자를 선언하여 외부에서 직접 접근하지 못하게 하고 getter, setter 메소드를 통해서만
	필드에 접근하도록 한다

2) 다형성(Polymorphism)
	다형성을 통해 같은 이름의 메소드가 객체에 따라 다르게 동작하도록 하는 것을 의미
	메소드 오버로딩, 메소드 오버라이딩, 참조변수의 다형성

3) 상속(Inheritance)
	기존 클래스의 필드와 메소드를 자식 클래스가 물려받아 쓰는 것을 의미(상속을 지원한다)
	상속은 extends 키워드를 사용한다
	단일상속만 지원한다(한번에 하나의 부모클래스만 상속 가능)

4) 추상화(Abstraction)
	불필요한 세부 구현을 숨기고 중요한 부분만 노출하는 것을 의미
	추상클래스, 인터페이스

5) 클래스와 객체
	모든 데이터를 클래스의 형태로 정의하며 객체는 클래스의 인스턴스
	클래스는 객체의 설계도 역할을 하며 필드(속성)와 메소드(동작)을 정의한다



11일차
	
1. 생성자
	클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않는다
	생성자는 리턴이라는 기능이 존재하지 않는다
	객체가 생성될 때 자동으로 실행되며, 주로 클래스의 필드를 초기화하는데 사용된다
	
	- 생성자는 클래스 이름과 동일한 이름을 가지며, 반환값이 없는 특별한 메소드이다

1) 생성자의 특징
	클래스 이름과 동일한 이름을 사용한다
	반환타입을 명시하지 않는다(void도 사용하지 않음)
	객체를 생성 시에 new 키워드를 통해 호출되며 직접 호출할 수 없다
	생성자를 정의하지 않으면 기본생성자(매개변수가 없는 생성자)가 자동으로 추가가 된다
	- 하지만 개발자가 생성자를 하나라도 정의하면 기본 생성자는 자동으로 만들어지지 않는다

2) 기본생성자
	public 클래스명(){}
	매개변수가 없다
	클래스 선언 시 자동으로 선언되며 사용자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다

3) this
	객체 자기자신, this는 자동으로 생성되는 변수이다
	현재 객체 자신을 참조하는 특별한 키워드
	클래스 내부에서 필드와 메소드를 가리킬 때 사용된다
	
- this 키워드를 사용하는 이유
	멤버변수(필드)와 지역변수나 매개변수의 이름이 동일할 때 구분
	가독성 향상
	다른 생성자 호출 및 메소드 체이닝 구현
	
4) 생성자 오버로딩
	하나의 클래스에 여러개의 생성자를 정의할 수 있다
	각 생성자는 매개변수의 개수, 타입, 순서가 달라야한다
	
5) this()
	자기자신의 생성자
	생성자 내부에서만 사용가능하며 최상단(첫번째 줄)에 작성해야한다
	-> 생성자 내부에서 나의 다른 생성자를 호출할 때 사용한다

final 변수 -> 상수

- 변수의 종류
	종류 		선언위치/특징				메모리영역		수명
	상수		final 키워드, 값 수정 불가능			상수 풀/스택	블록/클래스 종료 시 까지
	지역변수		메소드나 블록 내에서 선언			스택		메소드 종료 시 소멸
			외부에서 접근 불가
	매개변수		메소드 선언 시 전달 값을 받기위한 변수		스택		메소드 실행 중 유지
	인스턴스변수	클래스 내부에서 선언				힙		객체가 살아있는 동안
			객체마다 별도로 존재(객체명.인스턴스변수명)	
	정적변수		static 키워드				메소드		프로그램 시작부터 종료까지
			클래스 로딩 시 하나만 생성









