day11(java 9일차)
복습 -> 생성자 -> 오버로딩 -> this, this() -> static

0. 복습
1) 메소드
	하나의 기능을 하는 코드블록

- 메소드 정의
	반환타입 메소드명(자료형 매개변수){
		실행할문장;
		return 리턴값
	}

- 메소드 호출 방법
	void method1(){
		syso("안녕하세요");
	}

	매개변수 x 반환타입 x => 객체명.메소드명();
	매개변수 o 반환타입 x => 객체명.메소드명(인수);
	매개변수 o 반환타입 o => syso(객체명.메소드명(인수));
			    자료형 변수명 = 객체명.메소드명(인수);

2) 메소드 오버로딩
	하나의 메소드명으로 매개변수의 개수, 타입, 순서가 다를 때 정의할 수 있는 것을 의미
	객체지향언어 => 다형성의 특징 중 하나

3) 메소드와 메모리
	메소드 매개변수, 지역변수	Stack메모리
- 메소드를 사용하기 위한 2가지 방법
	메소드 정의할 때 선언부 static 키워드를 붙인다
	클래스의 객체를 만들어서 사용한다
	
	       참조변수  참조값
	클래스타입 객체명 = new 클래스명();
	------------   -----------
	Stack		Heap

4) 클래스
	사용자 정의 타입으로 필드와 메소드를 묶어서 관리할 수 있는 설계도

- 클래스의 특징
	사용자 정의 타입이다
	연관성 있는 저장공간과 기능을 한 곳에 모아 관리할 수 있다
	객체를 생성하기 위한 틀

- 클래스 선언
	class 클래스명 {
		//필드;
		//메소드;
	}

- 객체화(인스턴스화)
	클래스타입 객체명 = new 클래스명();
	클래스타입 참조변수 = new 생성자();

- 클래스 멤버에 접근
	객체명.필드명 = "값";
	syso(객체명.필드명);

	객체명.메소드명();
	객체명.메소드명(인수);
	syso(객체명.메소드명());
	syso(객체명.메소드명(인수,인수));

1. 생성자
	클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않는다
	생성자는 리턴이라는 기능이 존재하지 않는다
	객체가 생성될 때 자동으로 실행되며, 주로 클래스의 필드를 초기화하는데 사용된다
	
	- 생성자는 클래스 이름과 동일한 이름을 가지며, 반환값이 없는 특별한 메소드이다

1) 생성자의 특징
	클래스 이름과 동일한 이름을 사용한다
	반환타입을 명시하지 않는다(void도 사용하지 않음)
	객체를 생성 시에 new 키워드를 통해 호출되며 직접 호출할 수 없다
	생성자를 정의하지 않으면 기본생성자(매개변수가 없는 생성자)가 자동으로 추가가 된다
	- 하지만 개발자가 생성자를 하나라도 정의하면 기본 생성자는 자동으로 만들어지지 않는다

2) 기본생성자
	public 클래스명(){}
	매개변수가 없다
	클래스 선언 시 자동으로 선언되며 사용자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다

3) this
	객체 자기자신, this는 자동으로 생성되는 변수이다
	현재 객체 자신을 참조하는 특별한 키워드
	클래스 내부에서 필드와 메소드를 가리킬 때 사용된다
	
- this 키워드를 사용하는 이유
	멤버변수(필드)와 지역변수나 매개변수의 이름이 동일할 때 구분
	가독성 향상
	다른 생성자 호출 및 메소드 체이닝 구현
	
4) 생성자 오버로딩
	하나의 클래스에 여러개의 생성자를 정의할 수 있다
	각 생성자는 매개변수의 개수, 타입, 순서가 달라야한다
	
5) this()
	자기자신의 생성자
	생성자 내부에서만 사용가능하며 최상단(첫번째 줄)에 작성해야한다
	-> 생성자 내부에서 나의 다른 생성자를 호출할 때 사용한다
	
2. static
	정적인
	프로그램이 시작하면 생성되고 프로그램이 종료될 때까지 유지된다
	프로그램이 실행되는 동안 계속해서 유지되는 저장공간	

1) 정적멤버(Static Member)
	정적멤버는 클래스 자체에 속하는 멤버, 클래스를 통해 접근
	객체를 생성하지 않아도 사용할 수 있다
	정적변수와 정적메소드가 포함된다
	
- 정적변수 : 클래스의 모든 인스턴스(객체)에서 동일한 값을 공유, 객체 간의 정보 공유에 사용된다
- 정적메소드 : 객체를 생성하지 않아도 호출 가능하고 주로 유틸리티 메소드나 공통 동작을 구현하는데 사용한다

2) 멤버변수와 멤버메소드의 종류
	static이 붙은 변수 : static 변수, 클래스변수, 정적변수
	static이 붙지 않은 변수 : 인스턴스 변수

	static이 붙은 메소드 : static 메소드, 클래스 메소드, 정적 메소드
	static이 붙지 않은 메소드 : 인스턴스 메소드

3) static 변수와 static 메소드
	static 변수, static 메소드는 객체를 생성하지 않아도 클래스 이름을 통해 직접 사용할 수 있다
	객체의 생성과는 무관하게 클래스 로딩 시에 메모리에 올라가며 프로그램이 실행되는 동안 유지된다

	static 변수는 객체와 상관없이 하나의 저장공간이므로 모든 객체가 공유해서 사용한다
	즉, 모든 객체에 공통으로 사용되는 변수에 static을 붙이는 것을 고려한다

	static 메소드는 인스턴스 멤버를 직접 사용할 수 없다
	static 메소드가 메모리에서 사용 준비가 끝나고 인스턴스 멤버는 new를 사용하여 객체를 생성하기 전까지
	사용할 수 없기 때문이다

+) 정적변수는 클래스 수준에서 선언되며 클래스의 모든 객체 간에 공유되는 변수이다
	한 번 메모리에 할당되면 프로그램이 실행 중일 때 항상 존재하며 수정이 가능하다
	클래스가 처음 사용되거나 정적멤버에 접근하면 해당 클래스가 메모리에 로드되고
	클래스의 정적변수 및 정적메소드가 method 영역에 할당되는데 이 과정을 클래스 로딩이라고 한다
	정적 변수의 변경은 해당 클래스의 모든 객체에 영향을 끼친다
	method 영역은 가비지 컬렉션의 영향을 받지 않는다
	객체가 해제되더라도 method 영역에 할당된 데이터는 프로그램의 종료까지 유지된다

+) 메모리 구조
Method 영역
	- 모든 클래스와 static 멤버가 저장되는 영역
	- 클래스 로더가 클래스를 로드할 때 해당 클래스의 메타 데이터와 함께
	  static 변수와 static 메소드가 여기에 저장된다
	- 프로그램 실행 동안 유지되며 모든 객체가 공유한다

Heap 영역
	- new 키워드로 생성된 객체와 그 객체의 인스턴스 변수(필드)가 저장된다
	- 객체마다 별도의 저장공간을 가진다
	- Garbage Collector(가비지 컬렉터)가 관리한다

Stack 영역
	- 메소드의 지역변수, 매개변수와 메소드 실행정보가 저장되는 영역
	- 메소드가 호출될 때 스택 프레임이 생성되고 종료되면 프레임이 제거된다

PC Register(프로그램 카운터 레지스터)
	- 각 쓰레드가 실행 중인 명령어의 주소를 저장

Native Method Stack(네이티브 메소드 스택)
	- Java가 아닌 네이티브 코드(C, C++ 등)로 작성된 메소드를 호출 시 사용

-----------------------------------------
생성자
	객체 생성 시에 반드시 호출된다
	객체를 만들 때 초기 값을 넣을 때 사용한다
	클래스명 객체명 = new 생성자();

- 생성자 오버로딩
	객체를 만들 때 생성자의 매개변수의 타입, 순서, 개수가 다르면 여러 개를 선언할 수 있다
	
- this, this()
	this : 객체 자기자신, 참조값
	this() : 생성자 자기자신, 생성자 안에서만 호출, 최상단에 작성한다

- static
	변수, 메소드
	클래스명.스태택변수명;
	클래스명.메소드명();
	스태틱 변수에 담긴 값은 모든 객체가 공통된 값을 사용한다

- 메모리
	Heap	: 동적메모리
		new 키워드로 생성된 객체와 인스턴스 변수가 저장된다
	Stack	: 메소드의 지역변수, 매개변수, 메소드 실행정보가 저장된다

	Method	: static 키워드가 붙은 변수와 메소드
		프로그램 시작부터 끝까지 유지된다

- 전체 클래스(메소드, 필드 등) 통일화
- 메인 클래스

2팀 햄버거 주문 관리 시스템
필드 : 고객명, 버거종류, 세트여부(boolean), 총가격
메소드 : 
	- 주문메소드(황승우)
	- 판매메소드(이서진)
	- 환불메소드(이남혁)
	- 고객배달(민경승)
	- 메인메소드 및 클래스(전보라)
요구조건 :
	- 여러 주문을 배열로 저장
	- 모든 주문이 끝나면 마감 시 전체 매출합계 구하기




//우리가 마음에 여유가 있을 때 하기
관리자 하고 싶은 일
 : 관리자메뉴 - 고객확인/주문확인/총매출확인/로그아웃

** class 종류 : 관리시스템, 주문서, 버거, 고객

**고객의 id는 전화번호
**주문서 id는 주문번호

[main class]
boolean flag;

//전보라
while(flag){
	고객인스턴스 = 고객명, 주소, 전화번호
	환불/주문

	주문
	{
		배달여부 선택

		메뉴출력
		메뉴선택

		if (최소 금액 배달가능한지)

		주문서 생성

		주문(주문서);
	}
	환불 -> if(고객정보가 있는지)
	{
		환불
		[] = 관리시스템.주문리스트조회();
		출력

		선택입력
		정말?
		
		관리시스템.환불();
	}

	flag = 관리시스템.추가주문가능여부();
}

마감 총매출 출력

------------------------------------------------------------------

class 관리시스템
   매출, 주문서[], String 버거종류[], 최소금액, 고객[], int 주문갯수
	
   생성자() {
		주문서[] = [max_count]
		고객[] = [max_count]
	  }
   
   boolean 첫주문고객인지(전화번호); 
   고객정보입력(고객);


   주문(전화번호, 주문서); // 주문서 확인 // 황승우
   판매(); // 주문서추가//이서진
   환불(주문서 id); // 주문서 삭제 // 고객에 있는 주문아이디 삭제 //이남혁
   고객배달(); // 고객 배달 // 최소금액확인 //민경승

   boolean 추가주문가능여부()
	{ 
		if(주문갯수 < MAX_COUNT) 
			return true;
		return false;
	}

   주문리스트조회(고객정보);
------------------------------------------------------------------
class 주문서
   주문번호, 전화번호, 버거[], 총가격
   
   String get전화번호;
   int 총가격();
------------------------------------------------------------------
class 버거
   버거종류
   버거가격
   세트가격
   세트여부
------------------------------------------------------------------
class 고객
   고객명, 주소, 전화번호, 주문번호[]





	











